---
title: 가치없는 프론트엔드 테스트
date: 2021-12-30 15:02:00
category: 'Testing'
draft: false
---

# 실패할 가치가 있는 테스트를 만든다

“작은 함수로 테스트를 시작하는 건 좋은 접근이었습니다. 하지만 그게 private한 함수라면 효용성이 낮죠.“

제가 처음 시도한 테스트에 대한 프론트 팀 리드 Ted의 피드백이었습니다. 저는 **'Merlin(캐시노트 리뉴얼 버전 웹 저장소) 테스트 커버리지 10% 달성**'을 2021년 3분기 개인 목표로 잡았고, 일단 가장 시작하기 쉬워 보이는 부분을 찾아 테스트를 작성했습니다. 하지만 이는 결과적으로 근시안적인 접근이었습니다.

Ted가 테스트를 추가해보는 게 어떠냐고 제안하셨던 React 컴포넌트는 이렇게 생겼습니다.

```jsx
export default function AwesomeComponent() {
  /* 초기화 */

  const someState = (() => {
    if (/* condition1 */) return 'hi';
    if (/* condition2 */) return 'hello';
    if (/* condition3 */) return coolLib.func('bye');
  })()

  return <>{/* JSX 템플릿 */}</>
}
```

`someState`를 만들어내는 부분이 즉시실행 함수(IIFE)로 컴포넌트 코드 내에 선언돼 있었고, 여러 개의 조건문으로 인해 가독성이 떨어지는 상황이었습니다. 이 복잡한 IIFE를 밖으로 추출해서 테스트를 만드는 게 가장 쉬워 보였기 때문에 이것부터 시작했죠. 작게라도 성공 사례를 만들면, 동료들도 내가 작성한 가이드를 보면서 “이런 원리로 만들었구나”하고 쉽게 받아들일 수 있도록 하자는 생각이었습니다. 테스트를 만들고 난 후에는 “0.001%(?) 정도 테스트 커버리지가 올랐겠지”라는 생각에 뿌듯함도 살짝 느꼈습니다.

하지만 이 생각은 곧 바뀌었습니다. Ted와 주간 체크인 미팅에서 테스트를 검토한 결과, 이 함수는 완벽히 위 컴포넌트의 private 함수이고, 이런 함수는 테스트해봤자 큰 효용이 없다는 결론에 도달했습니다.

React 컴포넌트 테스트의 목적은 “이런 조건의 사용자에게는 이렇게 렌더링되는지”를 확인하는 데에 있습니다. 사실 사용자 입장에서는 직접적으로 외부로 노출되는 컴포넌트가 어떻게 렌더링되는지가 중요하지, 중간에 어떤 과정을 거쳐 렌더링 결과가 나왔는지는 중요하지 않습니다. 렌더링 결과만 동일하다면 내부 구현은 얼마든지 바뀌어도 됩니다. 거꾸로 말하면, 사용자에게는 정상적으로 컴포넌트가 표시되는 상태에서도 내부 구현에 대한 테스트는 실패할 수 있습니다. 따라서 내부 구현에 대한 테스트는, 실패하기는 쉬운데 실패했을 때 개발자에게 주는 유용한 정보는 별로 없는 (i.e., 구현 변경사항 맞춰 테스트를 그대로 변경하는) 상태가 되기 쉽습니다.

이를 통해 저는 테스트의 목적과 가치를 잘 고려해야 한다는 점을 배웠습니다. **여러 곳에서 여러 방법으로 사용되는 코드일수록 테스트할 가치가 높으며, 깨졌을 때 유용한 정보를 얻을 수 있습니다.** 위 코드에서는 `AwesomeComponent` 전체를 테스트하는게 더 가치가 높다고 볼 수 있습니다.

> TDD를 하고 있다면 얼마든지 private 함수를 테스트하게될 수 있습니다. 물론 그 브랜치가 머지되기 전에는 그때까지 만들어진 private 함수들의 테스트를 걷어내야겠지만요.
>
> _by Ted_

# 테스트를 위한 테스트는 피한다

이번에는 여러 곳에서 공통으로 사용하는 코드를 살펴봤습니다. `Merlin` 프로젝트에서는 여러 페이지에서 유사한 비즈니스 로직을 활용하는 코드를 분리해서 `domains` 라는 폴더 밑에서 별도 파일로 관리하고 있습니다. 태생부터가 여러 곳에서 사용하기 위한 코드이니만큼, `domains` 의 코드들은 분명 테스트 대상 1순위라고 볼 수 있습니다.

```jsx
export useComplicatedHook() {
  const { data1 } = useDomainRelated1(); // GraphQL API 호출
  const { data2 } = useDomainRelated2(); // GraphQL API 호출

  /* data1과 data2의 가공 및 처리 */

  return {
    // complicated object
  }
}
```

위 hook은 API 를 호출하는 부분과 데이터를 가공 및 처리하는 두 부분으로 이루어져 있습니다. 여기서 API를 호출하는 부분은 가짜 응답으로 mocking하는 것이 번거로우니, 테스트하기 쉽게 데이터를 가공 및 처리하는 부분을 별도 함수로 빼내서 테스트하는 건 어떨까, 라는 생각을 했습니다만.. (빼내려고 했던 코드가, 첫번째 사례처럼 hook의 입장에서 private 한 코드라는 점은 차치하고라도) 여기서도 좀 더 생각할 부분이 있다는 Ted의 지적을 받았습니다.

유지보수하기 더 쉬운 방향으로 코드 구조를 바꾸고, 그럼으로써 테스트하기 쉽게 되는 건 아주 좋습니다. 그러나 테스트하기 어렵다는 이유만으로 코드 구조를 바꾸는 것은 논리의 선후가 뒤바뀐 발상이 아닐까 싶습니다. 저로서는 피하고 싶은 ‘테스트만을 위한 테스트’입니다.

# 테스트 작성시 미리 고려할 사항들

TDD를 하고있는 상황이 아니라면, 테스트를 작성할 때 “Why”를 먼저 생각해 봐야합니다. 단순히 커버리지에 집중했다간 의미없이 시간낭비만 하게 되는 꼴이니까요. 앞으로 테스트 작성할 때 다음 사항들을 고려해봅시다.

- 테스트 대상이 여러 곳에서 사용되는가?
- 자명하지 않은 이유로 실패할 수 있는 테스트인가?
- 테스트를 더 용이하게 만들기 위해 구조를 바꿔야 한다면, 그 구조 변경이 테스트가 아닌 다른 측면의 이득도 주는가?

부족한 경험과 지식으로 테스트를 작성하다보면, 생각 이상으로 시간을 잡아먹는 부분이 많이 발생합니다.(특히나 삽질을 많이 하게 됩니다…) 때론 내가 잘 하고 있는건지, 허튼짓을 하는건 아닌지 의문이 들기도 합니다. 하지만 위 질문의 대답이 모두 Yes라면, 적어도 시간낭비를 하고 있는건 아니니 용기를 내어 마음껏 테스트를 작성해봅시다! 🙂
