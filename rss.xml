<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[goohooh.github.io]]></title><description><![CDATA[개발일지]]></description><link>https://goohooh.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 01 Jan 2022 05:13:36 GMT</lastBuildDate><item><title><![CDATA[소통하는 프론트엔드 TDD]]></title><description><![CDATA[새로운 프로젝트를 시작할 때면, ‘TDD…]]></description><link>https://goohooh.github.io/Testing/tdd/</link><guid isPermaLink="false">https://goohooh.github.io/Testing/tdd/</guid><pubDate>Thu, 30 Dec 2021 15:05:00 GMT</pubDate><content:encoded>&lt;p&gt;새로운 프로젝트를 시작할 때면, ‘TDD를 제대로 해보자!’ 라는 결심을 새해 다짐처럼 하곤 했습니다. 그리고 대부분의 다짐 처럼, 그리 성공적이지 못했습니다. 스펙변경/일정압박/귀찮음 등 다양한 이유로 포기하기 일쑤였습니다. 그러면서 코딩하는 매순간 마음 한켠에 불편함이 함께 자리잡게 됐습니다.&lt;/p&gt;
&lt;p&gt;‘나중에 이 코드에서 오류가 난다면, 테스트를 작성하지 않은 탓인데…’ 하는 걱정과
‘모두가 테스트 코드를 꼼꼼히 작성하진 않잖아… 누군가 테스트 없이 짠 코드를 고치는 내 꼴을 봐…! 그리고 쌓여있는 저 태스크들 안보여?’ 라는 자기위안이 늘 충돌하곤 했습니다.&lt;/p&gt;
&lt;p&gt;다행히 현 직장(KCD)에서 이러한 걱정들을 조금씩 덜 수 있게 됐습니다. 프로덕트 안정성을 위해 세운 여러 initiative중, TDD를 분기 목표로 잡을 수 있게 됐습니다. 그리고 때마침 팀 리드(Ted)와 1on1 미팅에서 ‘개발 커뮤니케이션 코스트’를 주제로 이야기를 나누다 다음과 같은 조언을 받게 됩니다.&lt;/p&gt;
&lt;p&gt;“Shortcut*에 기능 설명이 아닌 유저 스토리를 작성해보시죠!”&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;회사에서 업무관리 툴로 Shortcut을 사용합니다. Trello나 Jira와 비슷한 서비스입니다.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;user-journey&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#user-journey&quot; aria-label=&quot;user journey permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;User journey&lt;/h2&gt;
&lt;p&gt;Shortcut에서는 하나의 업무 단위를 &lt;strong&gt;Story&lt;/strong&gt;라고 표현합니다. Trello의 Card, Jira의 Issue같은 개념입니다. 조언대로 Story에 유저의 여정을 쪼개서 작성하기 시작했습니다. 개발 구현과 관련된 표현은 최대한 기입하지 않았습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;제목:&lt;/em&gt; 본인 인증이 완료된 유저는 계좌입력 페이지로 이동한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;본문:&lt;/em&gt; Figma 링크 및 개발/비지니스 배경 설명&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PM, 디자이너 혹은 관련자가 이 Story를 봤을 때 충분히 이해할 수 있는 수준으로 작성했습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;유저 입장에서 필요한 기능을 정의 내린다.&lt;/li&gt;
&lt;li&gt;유저 입장에서 실패/오류를 정의내린다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위와 같은 원칙을 기반으로 설계를 더 꼼꼼히 할 수 있으리라 기대했습니다. ‘개발중 커뮤니케이션 코스트를 줄이기 위한’ 액션 아이템으로써, 기대했던 대로 기획 당시 보이지 않았던 부분들을 발견할 수 있었습니다. 코딩전에 미리 PM/디자이너와 논의하였고 수정할 수 있었습니다. 만약 기능에 대한 설명만 Story에 작성했다면, 개발자 외에는 이러한 허점을 잘 발견하지 못했을 부분이었습니다. 그리고는 본격적인 개발에 착수했습니다. 새로운 브랜치를 만들고 시작하려는 찰나, 불편한 감정이 피어올랐습니다.&lt;/p&gt;
&lt;p&gt;‘TDD 안할거야…?’&lt;/p&gt;
&lt;p&gt;쓰라린 지난 기억들을 떠올리며 조금 망설였습니다. ‘그래도 시도해보자’ 마음을 다잡으며 이내 테스트 파일을 먼저 만들고 테스트를 작성했습니다. 그리고 신기하게도, 앞서 Story에 작성한 유저의 여정을 테스트 코드에 &lt;strong&gt;동일하게&lt;/strong&gt; 작성하기 시작했습니다. 이게 무슨 의미일까요?&lt;/p&gt;
&lt;h2 id=&quot;추상화&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B6%94%EC%83%81%ED%99%94&quot; aria-label=&quot;추상화 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;추상화&lt;/h2&gt;
&lt;p&gt;생각해보면 유저의 요구사항은 자연어로 등장합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;유저들의 포스트들을 필터링 해서 보고 싶어&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 듣고 필요한 기능들을 생각해봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포스트 목록을 리턴할 API&lt;/li&gt;
&lt;li&gt;포스트 목록을 필터링 할 UI 컴포넌트&lt;/li&gt;
&lt;li&gt;포스트 목록을 보여줄 UI 컴포넌트&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서 개발자라면 위 불렛 포인트들을 Task 관리 툴로 &lt;strong&gt;그대로 들고가서 똑같이&lt;/strong&gt; 작성할겁니다. 여기에 조금 더 상세한 기술적 디테일을 추가 하겠죠. 그리고 당연하게 이 목록을 업무 진행 척도로 여길겁니다. 하지만 이 티켓(숏컷이라면 스토리)를 보게될 PM이나 디자이너의 생각은 다를 수 있습니다.&lt;/p&gt;
&lt;p&gt;일단 무슨 말인지 모를 확률이 높습니다. 개발언어는 개발자들이나 알아듣습니다. 함께 일하는 사람들은 개발자일 수도 있지만 아닐 수도 있습니다. 티켓에서 어떠한 일들이 일어나는지 협업하는 사람들과 같은 Page에서 논의가 이루어져야합니다. 그러기 위해서 유저의 여정 처럼 고차원적이고 추상화된 레벨에서 이야기를 나누어야 합니다. 우리의 제품은 결국 유저를 위해 존재하니까요.&lt;/p&gt;
&lt;p&gt;기술적 언어들만 기입돼 있다면 놓친 스펙을 발견한다거나, 더 나은 유저 경험을 제공할 방법을 찾는 등 가치있는 논의는 멀어지게 됩니다. 그럴경우 해당 티켓은 개발이 시작되기 전부터 진행되는 동안 오로지 개발자 혼자만의 판단에 의존하게 됩니다. 개발이 시작되고 나서야 보이는 기획/설계 미스로 인해 발생하는 일정 지연, 커뮤니케이션 코스트를 생각한다면 이는 프로젝트의 큰 리스크로 이어집니다.&lt;/p&gt;
&lt;p&gt;협업 레벨(티켓, 스토리 등)에서 알맞게 추상화된 언어(유저 여정 중심)로 이야기를 나누고 실무자들은 각자의 필드에서 전문화된 언어로 업무를 진행하면 됩니다. 마치 컴퓨터의 Low-Level에서 사용하는 언어와 High-Level에서 사용하는 언어가 다르듯, 우리의 업무도 이와 동일해야합니다. 그렇게 최적화된 커뮤니케이션으로 최선의 제품을 생산할 수 있게됩니다.&lt;/p&gt;
&lt;h2 id=&quot;컨텍스트-스위칭-몰입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EB%AA%B0%EC%9E%85&quot; aria-label=&quot;컨텍스트 스위칭 몰입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;컨텍스트 스위칭, 몰입&lt;/h2&gt;
&lt;p&gt;예측한 일정 안에 개발을 완료했더라도 리뷰가 길어지는 경우도 있습니다. 이때 티켓과 일치된 테스트 시나리오는 리뷰어가 보다 쉽게 컨텍스트를 파악하도록 도와줍니다. 티켓과 PR을 오갈 필요 없이 테스트 시나리오를 통해 무슨 목적으로 코드가 작성됐는지 쉽게 파악이 가능하고, 몰입하여 수준높은 리뷰를 진행할 수 있게 도와줍니다.&lt;/p&gt;
&lt;p&gt;잘 작성한 유저 여정(=테스트 시나리오)는 비단 리뷰어 뿐아니라 개발자 스스로에게도 도움이 됩니다. 개발자가 하나 이상의 프로젝트를 진행할 수도 있습니다. 혹은 많은 미팅에 참석할수도 있죠. 이때 다시 코딩을 시작한다는 건 꽤나 에너지가 많이 필요한 일입니다. 이러한 컨텍스트 스위칭 과정에서 유저 여정을 읽는 것 만으로도 내가 어디까지 일했는지 몰입하는데 상당한 도움을 줍니다.&lt;/p&gt;
&lt;h2 id=&quot;tdd를-한다의-의미&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tdd%EB%A5%BC-%ED%95%9C%EB%8B%A4%EC%9D%98-%EC%9D%98%EB%AF%B8&quot; aria-label=&quot;tdd를 한다의 의미 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;‘TDD를 한다’의 의미&lt;/h2&gt;
&lt;p&gt;그동안 저는 TDD의 정의를 좁게만 생각하고 있었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실패를 방지하기 위해 시간을 더 투자하여 테스트를 먼저 작성하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;틀린 말은 아니지만 무언가 부족해 보입니다. 마치 &lt;strong&gt;개발자 혼자&lt;/strong&gt; 자기 만족을 위한 수단이자, 책임을 회피하기 위한 피난처로 TDD를 사용한 것처럼 보입니다. TDD를 지속하기 위한 강력한 동기로는 불충분 합니다. 그러다보니 그간 TDD를 쉽게 포기했던 것 같습니다.&lt;/p&gt;
&lt;p&gt;하지만 유저 스토리 작성과 그 과정속의 커뮤니케이션 과정을 함께 떠올리자, 더이상 TDD는 단순한 코딩이라는 행위가 아님을 깨달았습니다. 유저의 여정을 작성하여 코딩으로 이를 완성 시키는 것. 그렇게 성공적인 프로덕트를 만들기 위한 &lt;strong&gt;과정에서&lt;/strong&gt; TDD가 의미를 갖는다는 것을 말입니다. 그리하여 TDD는 테스트 커버리지 숫자로 그 존재감을 드러내는 것이 아니라 프로젝트가 원활히 진행되고 생산적인 커뮤니케이션이 이루어질 때 빛을 발하는 것이었습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[미니멀 프론트엔드 테스트]]></title><description><![CDATA[…]]></description><link>https://goohooh.github.io/Testing/worthy_testing/</link><guid isPermaLink="false">https://goohooh.github.io/Testing/worthy_testing/</guid><pubDate>Thu, 30 Dec 2021 15:02:00 GMT</pubDate><content:encoded>&lt;p&gt;테스트 커버리지는 얼마를 달성해야 좋을까요? 모든 코드는 테스트 대상이 돼야할까요? 하지만 테스트 작성 또한 비용이 들고 유지보수 대상이 됩니다. 이는 생산성 저하를 초래하여 프로젝트에 지장을 줄 수 있습니다.&lt;/p&gt;
&lt;h1 id=&quot;-실패할-가치가-있는-테스트를-작성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#-%EC%8B%A4%ED%8C%A8%ED%95%A0-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EB%8A%94-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot; 실패할 가치가 있는 테스트를 작성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;💎 실패할 가치가 있는 테스트를 작성한다&lt;/h1&gt;
&lt;p&gt;“작은 함수로 테스트를 시작하는 건 좋은 접근이었습니다. 하지만 그게 private한 함수라면 효용성이 낮죠.“&lt;/p&gt;
&lt;p&gt;회사에서 처음 작성한 테스트를 본 팀 리드(Ted)의 피드백이었습니다. 분기 목표로 맡고있던 프로젝트의 &lt;strong&gt;‘테스트 커버리지 10% 달성’&lt;/strong&gt;(당시 0%)‘을 잡았고, 일단 가장 시작하기 쉬워 보이는 부분을 찾아 테스트를 작성했습니다. 하지만 결과적으로 이는 근시안적인 접근이었습니다.&lt;/p&gt;
&lt;p&gt;테스트를 추가했던 부분은 다음과 같이 생겼습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;MyComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;/* 초기화 */&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; someState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* condition1 */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* condition2 */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* condition3 */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;c&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* someState를 사용하는 JSX */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;someState&lt;/code&gt;를 만들어내는 부분이 즉시실행 함수(IIFE)로 컴포넌트 코드 내에 선언돼 있었고, 여러 개의 조건문으로 인해 가독성이 떨어지는 상황이었습니다. 이 복잡한 IIFE를 밖으로 빼내고 테스트를 만드는 게 가장 쉬워 보였습니다. 작게라도 케이스를 만들면, 동료들도 제가 작성한 가이드를 보면서 “이렇게 만들었구나”하고 쉽게 받아들일 수 있도록 하자는 생각이었습니다. 테스트 작성 후에는 조금이라도 테스트 커버리지가 올랐다는 생각에 뿌듯함도 살짝 느꼈습니다.&lt;/p&gt;
&lt;p&gt;하지만 Ted와 테스트를 검토한 결과, 추출된 함수는 완벽히 &lt;code class=&quot;language-text&quot;&gt;MyComponent&lt;/code&gt;의 private 함수였습니다 private 함수는 테스트해봤자 큰 효용이 없다는 말에 수긍했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘private’의 의미를 단순히 &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; 키워드 사용여부로 한정 짓지 않고 있습니다. 외부로 노출되지 않고, 재사용되지 않으면 ‘private 하다’라는 의미로 사용하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;요구사항이 바뀌어 구현이 변경돼야 한다면, 개발자는 직관적으로 위 함수만 변경해야 함을 알 수 있습니다. 당연히 작성한 테스트도 바뀌어야합니다. 여기서 private 함수 테스트가 큰 가치를 제공하지 못했다는 눈치 챌 수 있습니다. 오히려 동어반복적인 작업을 하는 부담만 줄 뿐입니다.&lt;/p&gt;
&lt;p&gt;만약 함수가 public 했다면? 다른 곳에서도 사용됐다면? 변경으로 인해 다른 곳에 작성된 테스트가 실패했을 것이고 개발자는 미리 버그를 잡을 수 있게 됩니다. 테스트는 실패할 확률이 높을 때 가치가 올라갑니다.&lt;/p&gt;
&lt;p&gt;여러 곳에서 여러 방법으로 사용되는 코드일수록 테스트할 가치가 높으며, 깨졌을 때 유용한 정보를 얻을 수 있습니다. 위 코드에서는 차라리 하나의 화면을 책임지면서 public하기도 한 &lt;code class=&quot;language-text&quot;&gt;MyComponent&lt;/code&gt; 전체를 테스트하는게 더 가치가 높다고 볼 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TDD를 하고 있다면 얼마든지 private 함수를 테스트하게 될 수 있습니다. 물론 그 브랜치가 머지되기 전에 private 함수 테스트를 걷어내야겠지만요.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Ted&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;-테스트만을-위한-테스트는-피한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A7%8C%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%ED%94%BC%ED%95%9C%EB%8B%A4&quot; aria-label=&quot; 테스트만을 위한 테스트는 피한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;😔 테스트만을 위한 테스트는 피한다&lt;/h1&gt;
&lt;p&gt;앞선 교훈을 발판삼아 이번엔 여러 곳에서 공통으로 사용하는 코드를 살펴봤습니다. 프로젝트 구조를 살짝 설명드리자면, 여러 페이지에 걸쳐 유사한 비즈니스 로직을 활용하는 코드를 분리해서 &lt;code class=&quot;language-text&quot;&gt;domains&lt;/code&gt; 라는 폴더 밑에서 별도로 관리하고 있습니다. 태생부터가 여러 곳에서 사용하기 위한 코드이니만큼, &lt;code class=&quot;language-text&quot;&gt;domains&lt;/code&gt; 하위의 코드들은 분명 테스트 대상 1순위라고 볼 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useComplexHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; data1 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useDomainRelated1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// API 호출&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; data2 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useDomainRelated2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// API 호출&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;/* 복잡한 data1 &amp;amp; data2 가공 및 처리 */&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// data1 &amp;amp; data2 기반 복잡한 객체&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 custom hook은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 호출&lt;/li&gt;
&lt;li&gt;데이터 가공 및 처리&lt;/li&gt;
&lt;li&gt;여러 key/value를 갖는 객체 리턴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;크게 3가지 부분으로 이루어져 있습니다. 나름 테스트에 익숙해진 지금 보자면 API 호출부를 mocking하고, 리턴값을 assertion하여 테스트를 작성하면 되겠다는 생각이 바로 떠오릅니다.&lt;/p&gt;
&lt;p&gt;하지만 아직 react hook 테스트가 익숙치 않았던 당시엔 &lt;em&gt;‘테스트하기 쉽게 데이터 가공/처리 부를 별도 함수로 빼내서 테스트하는 건 어떨까’&lt;/em&gt; 생각 했습니다만… 이는 첫번째 사례에서 저질렀던 실수의 반복이었습니다. &lt;code class=&quot;language-text&quot;&gt;useComplexHook&lt;/code&gt;의 private한 함수를 만들어 테스트하는 꼴입니다.&lt;/p&gt;
&lt;p&gt;Ted는 추가로 생각할 지점을 일러주었습니다. 유지보수하기 더 쉽게 코드 구조를 바꾸고, 그럼으로써 테스트하기 &lt;strong&gt;쉽게&lt;/strong&gt; 되는 건 좋습니다. 그러나 테스트하기 &lt;strong&gt;쉬워진다는 이유만으로&lt;/strong&gt; 코드 구조를 바꾸는 것은 논리의 선후가 뒤바뀐 발상이라는 것입니다.&lt;/p&gt;
&lt;h1 id=&quot;-테스트-작성-전-고려사항&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1-%EC%A0%84-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD&quot; aria-label=&quot; 테스트 작성 전 고려사항 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;✍ 테스트 작성 전 고려사항&lt;/h1&gt;
&lt;p&gt;TDD를 하고있는 상황이 아니라면, 테스트를 작성시 “Why”를 먼저 생각해 봐야합니다. 단순히 커버리지에 집중했다간 의미없이 시간낭비만 하게 되는 꼴이니까요. 테스트 작성시 다음 사항들을 고려해봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 대상이 여러 곳에서 사용되는가?&lt;/li&gt;
&lt;li&gt;자명하지 않은 이유로 실패할 수 있는 테스트인가?&lt;/li&gt;
&lt;li&gt;테스트를 더 용이하게 만들기 위해 기존 코드구조를 바꿔야 한다면, 테스트 이외의 측면에도 이점이 있는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;부족한 경험과 지식으로 테스트를 작성하다보면, 생각 이상으로 시간을 잡아먹는 부분이 많이 발생합니다.(삽질을 많이 하게 됩니다…) 그리고 때론 내가 잘 하고 있는건지, 허튼짓을 하는건 아닌지 의문이 들기도 합니다. 요구사항은 바뀌기 마련이고 이에따라 코드도 변경해야 하는데, 작성해둔 테스트가 짐짝처럼 느껴질 수도 있습니다. 이런 경험이 반복되면 테스트 작성 의지를 잃어버릴 수도 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 위 3가지 질문의 대답이 모두 Yes라면, 결코 시간낭비를 하고 있는건 아니니 용기 내어 마음껏 테스트를 작성해보시길 바랍니다. 분명 그 노력은 헛되지 않고, 이후 여러분이 즐겁고 마음 편히 프로젝트를 진행하도록 도와줄 것입니다. 🙏&lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[Phil ❤ agile]]></description><link>https://goohooh.github.io/resume-en/</link><guid isPermaLink="false">https://goohooh.github.io/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;phil&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#phil&quot; aria-label=&quot;phil permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Phil&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;❤ agile&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>